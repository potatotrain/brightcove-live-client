=begin
#Live API Reference

#Reference for the Brightcove Live API, used to create and manage live streaming events.  For additional in-depth guides to features of the API, see the **[Support Site](https://support.brightcove.com/live-api)**.  **Base URL**: https://api.bcovlive.io/v1

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 4.0.0

=end

require 'date'

module OpenapiClient
  class CreateLiveJobRequestBodyOutputs
    # Adjust the loudness level of the audio. This is measured in LUFS and specified in dB. This is useful to set the output loudness level to conform to a standard (-23dB for EBU R.128) The recommended setting is -23.
    attr_accessor :ad_audio_loudness_level

    # An output bitrate setting for the audio track, in Kbps
    attr_accessor :audio_bitrate

    # The output audio codec to use. Note: Only `aac` is supported.
    attr_accessor :audio_codec

    # Specifying `color_full_width`as `true` will force a color range conversion of input video file to \"full\", if it is \"limited\". By default, the encoder will not try to change the range.  Note:   - `color_full_width` cannot be used with \"copy_video\": true   - This option conflicts with video transmuxing
    attr_accessor :color_full_width

    # Specifying copy_audio will take the audio track from the input video file and transmux it into the resulting output file.
    attr_accessor :copy_audio

    # Specifying copy_video will take the video track from the input video file and transmux it into the resulting output file.
    attr_accessor :copy_video

    # The name for credentials with private and public keys can be stored with Brightcove to avoid passing plain text on API requests. This is required if the S3 or FTP origins are restricted. If credentials are not provided, it will be assumed that the origin restrictions are set to public or credentials are passed along with the URL.
    attr_accessor :credentials

    # H.264 has three commonly-used profiles: Baseline (lowest), Main, and High. Lower levels are easier to decode, but higher levels offer better compression. For the best compression quality, choose High. For playback on low-CPU machines or many mobile devices, choose `baseline`.
    attr_accessor :h264_profile

    # Video frame height. If no `width` or `height` is supplied, the source dimensions are used. If either `width` or `height` is supplied, the other dimension will be calculated to maintain the aspect ratio of the source.
    attr_accessor :height

    # Video frame width. If no `width` or `height` is supplied, the source dimensions are used. If either `width` or `height` is supplied, the other dimension will be calculated to maintain the aspect ratio of the source.
    attr_accessor :width

    # The maximum number of frames between each keyframe. If you set a low keyframe_interval it will increase the size / decrease the quality of your output file, but it will allow more precise scrubbing in most players. Itâ€™s recommended to have at least one keyframe per segment. If keyframe_interval is not provided, keyframes will follow the input GOP structure.
    attr_accessor :keyframe_interval

    # Label for the live or VOD asset.
    attr_accessor :label

    # Only applicable for instant mode VODs. Indicates which playlist to use to create a VOD output (from the live job). Only necessary if custom playlists were defined at live job creation.
    attr_accessor :playlist_label

    # Expedite VOD publishing by leveraging existing live renditions and segment boundaries
    attr_accessor :mode

    # For jobs, setting live_stream to true indicates the output is a live rendition. If live_stream is false, or is not set, the output will be treated as a VOD output.
    attr_accessor :live_stream

    # Array of notification destination objects or strings - notifications defined here are for job-level events.  A notification will be sent to the destination when selected event occurs. You can use a simple string with a url: &quot;http://log:pass@httpbin.org/post&quot;, or you can use an object. See [Events](https://support.brightcove.com/live-api-notifications#Events) for an explanation of the events reported in `state_changed` notifications. <br> Retry strategy: In the event of a failed request to send a notification, the default retry strategy is to retry 50 times with an exponential delay between attempts: <br> `max_retry_times = 50` <br> `delay_delta_s = 5` <br> `next_retry = now_s + retry_count * delay_delta_s`
    attr_accessor :notifications

    # Indicates what rendition to use to create a VOD output (from the live job) or which renditions to use. By default, the system uses any transmuxed rendition or the highest resolution output if there is no transmuxed output.
    attr_accessor :rendition_label

    # Sets the maximum duration of each segment in a segmented output.
    attr_accessor :segment_seconds

    # Specifying skip_audio removes the audio track.
    attr_accessor :skip_audio

    # Specifying skip_video removes the video track.
    attr_accessor :skip_video

    # 'When creating a playlist, the streams field is used to define which output renditions (by label) should be included in the manifest. Example format [{&quot;source&quot;: &quot;1080p&quot;}, {&quot;source&quot;: &quot;720p&quot;}].'
    attr_accessor :streams

    # The only type supported is a playlist. This is used for generating multiple master playlists with different renditions in the HLS manifest with the defined stream labels.
    attr_accessor :type

    # For VOD, `url` is mandatory (**unless** the destination is `videocloud`, in which case you dod **not** include the `url`) and sets the destination of the final asset destination. For access restricted origins, the credentials a can be passed along with the URL or stored within the Brightcove system. For Live, this is reserved for future use.
    attr_accessor :url

    # target video bitrate in kbps
    attr_accessor :video_bitrate

    # The output video codec. Note: Only `h264` is supported.
    attr_accessor :video_codec

    attr_accessor :videocloud

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'ad_audio_loudness_level' => :'ad_audio_loudness_level',
        :'audio_bitrate' => :'audio_bitrate',
        :'audio_codec' => :'audio_codec',
        :'color_full_width' => :'color_full_width',
        :'copy_audio' => :'copy_audio',
        :'copy_video' => :'copy_video',
        :'credentials' => :'credentials',
        :'h264_profile' => :'h264_profile',
        :'height' => :'height',
        :'width' => :'width',
        :'keyframe_interval' => :'keyframe_interval',
        :'label' => :'label',
        :'playlist_label' => :'playlist_label',
        :'mode' => :'mode',
        :'live_stream' => :'live_stream',
        :'notifications' => :'notifications',
        :'rendition_label' => :'rendition_label',
        :'segment_seconds' => :'segment_seconds',
        :'skip_audio' => :'skip_audio',
        :'skip_video' => :'skip_video',
        :'streams' => :'streams',
        :'type' => :'type',
        :'url' => :'url',
        :'video_bitrate' => :'video_bitrate',
        :'video_codec' => :'video_codec',
        :'videocloud' => :'videocloud'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'ad_audio_loudness_level' => :'Float',
        :'audio_bitrate' => :'Float',
        :'audio_codec' => :'String',
        :'color_full_width' => :'Boolean',
        :'copy_audio' => :'Boolean',
        :'copy_video' => :'Boolean',
        :'credentials' => :'String',
        :'h264_profile' => :'String',
        :'height' => :'Integer',
        :'width' => :'Integer',
        :'keyframe_interval' => :'Integer',
        :'label' => :'String',
        :'playlist_label' => :'String',
        :'mode' => :'String',
        :'live_stream' => :'Boolean',
        :'notifications' => :'Array<OneOfstringobject>',
        :'rendition_label' => :'String',
        :'segment_seconds' => :'Float',
        :'skip_audio' => :'Boolean',
        :'skip_video' => :'Boolean',
        :'streams' => :'Object',
        :'type' => :'String',
        :'url' => :'String',
        :'video_bitrate' => :'Integer',
        :'video_codec' => :'String',
        :'videocloud' => :'CreateVodClipbodyOutputsVideocloud'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `OpenapiClient::CreateLiveJobRequestBodyOutputs` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `OpenapiClient::CreateLiveJobRequestBodyOutputs`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'ad_audio_loudness_level')
        self.ad_audio_loudness_level = attributes[:'ad_audio_loudness_level']
      end

      if attributes.key?(:'audio_bitrate')
        self.audio_bitrate = attributes[:'audio_bitrate']
      else
        self.audio_bitrate = 192
      end

      if attributes.key?(:'audio_codec')
        self.audio_codec = attributes[:'audio_codec']
      else
        self.audio_codec = 'aac'
      end

      if attributes.key?(:'color_full_width')
        self.color_full_width = attributes[:'color_full_width']
      end

      if attributes.key?(:'copy_audio')
        self.copy_audio = attributes[:'copy_audio']
      end

      if attributes.key?(:'copy_video')
        self.copy_video = attributes[:'copy_video']
      end

      if attributes.key?(:'credentials')
        self.credentials = attributes[:'credentials']
      end

      if attributes.key?(:'h264_profile')
        self.h264_profile = attributes[:'h264_profile']
      end

      if attributes.key?(:'height')
        self.height = attributes[:'height']
      else
        self.height = 480
      end

      if attributes.key?(:'width')
        self.width = attributes[:'width']
      else
        self.width = 640
      end

      if attributes.key?(:'keyframe_interval')
        self.keyframe_interval = attributes[:'keyframe_interval']
      end

      if attributes.key?(:'label')
        self.label = attributes[:'label']
      end

      if attributes.key?(:'playlist_label')
        self.playlist_label = attributes[:'playlist_label']
      end

      if attributes.key?(:'mode')
        self.mode = attributes[:'mode']
      end

      if attributes.key?(:'live_stream')
        self.live_stream = attributes[:'live_stream']
      end

      if attributes.key?(:'notifications')
        if (value = attributes[:'notifications']).is_a?(Array)
          self.notifications = value
        end
      end

      if attributes.key?(:'rendition_label')
        self.rendition_label = attributes[:'rendition_label']
      end

      if attributes.key?(:'segment_seconds')
        self.segment_seconds = attributes[:'segment_seconds']
      end

      if attributes.key?(:'skip_audio')
        self.skip_audio = attributes[:'skip_audio']
      end

      if attributes.key?(:'skip_video')
        self.skip_video = attributes[:'skip_video']
      end

      if attributes.key?(:'streams')
        self.streams = attributes[:'streams']
      end

      if attributes.key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.key?(:'url')
        self.url = attributes[:'url']
      end

      if attributes.key?(:'video_bitrate')
        self.video_bitrate = attributes[:'video_bitrate']
      end

      if attributes.key?(:'video_codec')
        self.video_codec = attributes[:'video_codec']
      end

      if attributes.key?(:'videocloud')
        self.videocloud = attributes[:'videocloud']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level > 60
        invalid_properties.push('invalid value for "ad_audio_loudness_level", must be smaller than or equal to 60.')
      end

      if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level < -60
        invalid_properties.push('invalid value for "ad_audio_loudness_level", must be greater than or equal to -60.')
      end

      if !@audio_bitrate.nil? && @audio_bitrate > 1024
        invalid_properties.push('invalid value for "audio_bitrate", must be smaller than or equal to 1024.')
      end

      if !@audio_bitrate.nil? && @audio_bitrate < 16
        invalid_properties.push('invalid value for "audio_bitrate", must be greater than or equal to 16.')
      end

      if !@keyframe_interval.nil? && @keyframe_interval > 600
        invalid_properties.push('invalid value for "keyframe_interval", must be smaller than or equal to 600.')
      end

      if !@keyframe_interval.nil? && @keyframe_interval < 1
        invalid_properties.push('invalid value for "keyframe_interval", must be greater than or equal to 1.')
      end

      if @label.nil?
        invalid_properties.push('invalid value for "label", label cannot be nil.')
      end

      if @live_stream.nil?
        invalid_properties.push('invalid value for "live_stream", live_stream cannot be nil.')
      end

      if @segment_seconds.nil?
        invalid_properties.push('invalid value for "segment_seconds", segment_seconds cannot be nil.')
      end

      if @segment_seconds > 20
        invalid_properties.push('invalid value for "segment_seconds", must be smaller than or equal to 20.')
      end

      if @segment_seconds < 2
        invalid_properties.push('invalid value for "segment_seconds", must be greater than or equal to 2.')
      end

      if @video_bitrate.nil?
        invalid_properties.push('invalid value for "video_bitrate", video_bitrate cannot be nil.')
      end

      if @video_bitrate > 10000
        invalid_properties.push('invalid value for "video_bitrate", must be smaller than or equal to 10000.')
      end

      if @video_bitrate < 64
        invalid_properties.push('invalid value for "video_bitrate", must be greater than or equal to 64.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level > 60
      return false if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level < -60
      return false if !@audio_bitrate.nil? && @audio_bitrate > 1024
      return false if !@audio_bitrate.nil? && @audio_bitrate < 16
      audio_codec_validator = EnumAttributeValidator.new('String', ["aac"])
      return false unless audio_codec_validator.valid?(@audio_codec)
      h264_profile_validator = EnumAttributeValidator.new('String', ["baseline", "main", "high"])
      return false unless h264_profile_validator.valid?(@h264_profile)
      return false if !@keyframe_interval.nil? && @keyframe_interval > 600
      return false if !@keyframe_interval.nil? && @keyframe_interval < 1
      return false if @label.nil?
      mode_validator = EnumAttributeValidator.new('String', ["instant"])
      return false unless mode_validator.valid?(@mode)
      return false if @live_stream.nil?
      return false if @segment_seconds.nil?
      return false if @segment_seconds > 20
      return false if @segment_seconds < 2
      type_validator = EnumAttributeValidator.new('String', ["playlist"])
      return false unless type_validator.valid?(@type)
      return false if @video_bitrate.nil?
      return false if @video_bitrate > 10000
      return false if @video_bitrate < 64
      video_codec_validator = EnumAttributeValidator.new('String', ["h264"])
      return false unless video_codec_validator.valid?(@video_codec)
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] ad_audio_loudness_level Value to be assigned
    def ad_audio_loudness_level=(ad_audio_loudness_level)
      if !ad_audio_loudness_level.nil? && ad_audio_loudness_level > 60
        fail ArgumentError, 'invalid value for "ad_audio_loudness_level", must be smaller than or equal to 60.'
      end

      if !ad_audio_loudness_level.nil? && ad_audio_loudness_level < -60
        fail ArgumentError, 'invalid value for "ad_audio_loudness_level", must be greater than or equal to -60.'
      end

      @ad_audio_loudness_level = ad_audio_loudness_level
    end

    # Custom attribute writer method with validation
    # @param [Object] audio_bitrate Value to be assigned
    def audio_bitrate=(audio_bitrate)
      if !audio_bitrate.nil? && audio_bitrate > 1024
        fail ArgumentError, 'invalid value for "audio_bitrate", must be smaller than or equal to 1024.'
      end

      if !audio_bitrate.nil? && audio_bitrate < 16
        fail ArgumentError, 'invalid value for "audio_bitrate", must be greater than or equal to 16.'
      end

      @audio_bitrate = audio_bitrate
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] audio_codec Object to be assigned
    def audio_codec=(audio_codec)
      validator = EnumAttributeValidator.new('String', ["aac"])
      unless validator.valid?(audio_codec)
        fail ArgumentError, "invalid value for \"audio_codec\", must be one of #{validator.allowable_values}."
      end
      @audio_codec = audio_codec
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] h264_profile Object to be assigned
    def h264_profile=(h264_profile)
      validator = EnumAttributeValidator.new('String', ["baseline", "main", "high"])
      unless validator.valid?(h264_profile)
        fail ArgumentError, "invalid value for \"h264_profile\", must be one of #{validator.allowable_values}."
      end
      @h264_profile = h264_profile
    end

    # Custom attribute writer method with validation
    # @param [Object] keyframe_interval Value to be assigned
    def keyframe_interval=(keyframe_interval)
      if !keyframe_interval.nil? && keyframe_interval > 600
        fail ArgumentError, 'invalid value for "keyframe_interval", must be smaller than or equal to 600.'
      end

      if !keyframe_interval.nil? && keyframe_interval < 1
        fail ArgumentError, 'invalid value for "keyframe_interval", must be greater than or equal to 1.'
      end

      @keyframe_interval = keyframe_interval
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] mode Object to be assigned
    def mode=(mode)
      validator = EnumAttributeValidator.new('String', ["instant"])
      unless validator.valid?(mode)
        fail ArgumentError, "invalid value for \"mode\", must be one of #{validator.allowable_values}."
      end
      @mode = mode
    end

    # Custom attribute writer method with validation
    # @param [Object] segment_seconds Value to be assigned
    def segment_seconds=(segment_seconds)
      if segment_seconds.nil?
        fail ArgumentError, 'segment_seconds cannot be nil'
      end

      if segment_seconds > 20
        fail ArgumentError, 'invalid value for "segment_seconds", must be smaller than or equal to 20.'
      end

      if segment_seconds < 2
        fail ArgumentError, 'invalid value for "segment_seconds", must be greater than or equal to 2.'
      end

      @segment_seconds = segment_seconds
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] type Object to be assigned
    def type=(type)
      validator = EnumAttributeValidator.new('String', ["playlist"])
      unless validator.valid?(type)
        fail ArgumentError, "invalid value for \"type\", must be one of #{validator.allowable_values}."
      end
      @type = type
    end

    # Custom attribute writer method with validation
    # @param [Object] video_bitrate Value to be assigned
    def video_bitrate=(video_bitrate)
      if video_bitrate.nil?
        fail ArgumentError, 'video_bitrate cannot be nil'
      end

      if video_bitrate > 10000
        fail ArgumentError, 'invalid value for "video_bitrate", must be smaller than or equal to 10000.'
      end

      if video_bitrate < 64
        fail ArgumentError, 'invalid value for "video_bitrate", must be greater than or equal to 64.'
      end

      @video_bitrate = video_bitrate
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] video_codec Object to be assigned
    def video_codec=(video_codec)
      validator = EnumAttributeValidator.new('String', ["h264"])
      unless validator.valid?(video_codec)
        fail ArgumentError, "invalid value for \"video_codec\", must be one of #{validator.allowable_values}."
      end
      @video_codec = video_codec
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          ad_audio_loudness_level == o.ad_audio_loudness_level &&
          audio_bitrate == o.audio_bitrate &&
          audio_codec == o.audio_codec &&
          color_full_width == o.color_full_width &&
          copy_audio == o.copy_audio &&
          copy_video == o.copy_video &&
          credentials == o.credentials &&
          h264_profile == o.h264_profile &&
          height == o.height &&
          width == o.width &&
          keyframe_interval == o.keyframe_interval &&
          label == o.label &&
          playlist_label == o.playlist_label &&
          mode == o.mode &&
          live_stream == o.live_stream &&
          notifications == o.notifications &&
          rendition_label == o.rendition_label &&
          segment_seconds == o.segment_seconds &&
          skip_audio == o.skip_audio &&
          skip_video == o.skip_video &&
          streams == o.streams &&
          type == o.type &&
          url == o.url &&
          video_bitrate == o.video_bitrate &&
          video_codec == o.video_codec &&
          videocloud == o.videocloud
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [ad_audio_loudness_level, audio_bitrate, audio_codec, color_full_width, copy_audio, copy_video, credentials, h264_profile, height, width, keyframe_interval, label, playlist_label, mode, live_stream, notifications, rendition_label, segment_seconds, skip_audio, skip_video, streams, type, url, video_bitrate, video_codec, videocloud].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        OpenapiClient.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
