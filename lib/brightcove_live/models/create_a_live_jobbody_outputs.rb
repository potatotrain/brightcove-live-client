=begin
#Live API Reference

#Reference for the Brightcove Live API, used to create and manage live streaming events.

OpenAPI spec version: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 3.0.1

=end

require 'date'

module BrightcoveLive
  class CreateALiveJobbodyOutputs
    # Label for the live or VOD asset.
    attr_accessor :label

    # For jobs, setting live_stream to true indicates the output is a live rendition. If live_stream is false, or is not set, the output will be treated as a VOD output.
    attr_accessor :live_stream

    # The maximum number of frames between each keyframe. If you set a low keyframe_interval it will increase the size / decrease the quality of your output file, but it will allow more precise scrubbing in most players. Itâ€™s recommended to have at least one keyframe per segment. If keyframe_interval is not provided, keyframes will follow the input GOP structure.
    attr_accessor :keyframe_interval

    # target video bitrate in kbps
    attr_accessor :video_bitrate

    # An output bitrate setting for the audio track, in Kbps
    attr_accessor :audio_bitrate

    # Sets the maximum duration of each segment in a segmented output.
    attr_accessor :segment_seconds

    # Clipping API option 1. Duration (in seconds) to clip back from Live. Note: Clipping API only requires one of the three options for specifying duration or time.
    attr_accessor :duration

    # Adjust the loudness level of the audio. This is measured in LUFS and specified in dB. This is useful to set the output loudness level to conform to a standard (-23dB for EBU R.128) The recommended setting is -23.
    attr_accessor :ad_audio_loudness_level

    # Clipping API option 2. An offset, in seconds, from the start of the live stream to mark the beginning of the clip. Note: Clipping API only requires one of the three options for specifying duration or time.
    attr_accessor :stream_start_time

    # Clipping API option 2. An offset, in seconds, from the start of the live stream to mark the end of the clip. Note: Clipping API only requires one of the three options for specifying duration or time.
    attr_accessor :stream_end_time

    # Clipping API option 3. Universal epoch time, in seconds, to mark the beginning of the clip. Note: Clipping API only requires one of the three options for specifying duration or time.
    attr_accessor :start_time

    # Clipping API option 3. Universal epoch time, in seconds, to mark the end of the clip. Note: Clipping API only requires one of the three options for specifying duration or time.
    attr_accessor :end_time

    # Specifying copy_video will take the video track from the input video file and transmux it into the resulting output file.
    attr_accessor :copy_video

    # Specifying copy_audio will take the audio track from the input video file and transmux it into the resulting output file.
    attr_accessor :copy_audio

    # Specifying skip_video removes the video track.
    attr_accessor :skip_video

    # Specifying skip_audio removes the audio track.
    attr_accessor :skip_audio

    # Video frame width. If no width is supplied, we will use 640 pixels.
    attr_accessor :width

    # Video frame height. If no height is supplied, we will use 480 pixels.
    attr_accessor :height

    # The output video codec. Note: Only `h264` is supported.
    attr_accessor :video_codec

    # H.264 has three commonly-used profiles: Baseline (lowest), Main, and High. Lower levels are easier to decode, but higher levels offer better compression. For the best compression quality, choose High. For playback on low-CPU machines or many mobile devices, choose `baseline`.
    attr_accessor :h264_profile

    # The output audio codec to use. Note: Only `aac` is supported.
    attr_accessor :audio_codec

    # Array of notification destination objects or strings - notifications defined here are for job-level events.  A notification will be sent to the destination when selected event occurs. You can use a simple string with a url: &quot;http://log:pass@httpbin.org/post&quot;, or you can use an object. See [Events](https://support.brightcove.com/live-api-notifications#Events) for an explanation of the events reported in `state_changed` notifications.
    attr_accessor :notifications

    # Indicates what rendition to use to create a VOD output (from the live job) or which renditions to use. By default, the system uses any transmuxed rendition or the highest resolution output if there is no transmuxed output.
    attr_accessor :rendition_label

    # The only type supported is a playlist. This is used for generating multiple master playlists with different renditions in the HLS manifest with the defined stream labels.
    attr_accessor :type

    # When creating a playlist, the streams field is used to define which output renditions (by label) should be included in the manifest. Example format [{&quot;source&quot;: &quot;1080p&quot;}, {&quot;source&quot;: &quot;720p&quot;}].
    attr_accessor :streams

    # For VOD, URL is mandatory and sets the destination of the final asset destination. For access restricted origins, the credentials a can be passed along with the URL or stored within the Brightcove system. For Live, this is reserved for future use.
    attr_accessor :url

    # The name for credentials with private and public keys can be stored with Brightcove to avoid passing plain text on API requests. This is required if the S3 or FTP origins are restricted. If credentials are not provided, it will be assumed that the origin restrictions are set to public or credentials are passed along with the URL.
    attr_accessor :credentials

    attr_accessor :videocloud

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'label' => :'label',
        :'live_stream' => :'live_stream',
        :'keyframe_interval' => :'keyframe_interval',
        :'video_bitrate' => :'video_bitrate',
        :'audio_bitrate' => :'audio_bitrate',
        :'segment_seconds' => :'segment_seconds',
        :'duration' => :'duration',
        :'ad_audio_loudness_level' => :'ad_audio_loudness_level',
        :'stream_start_time' => :'stream_start_time',
        :'stream_end_time' => :'stream_end_time',
        :'start_time' => :'start_time',
        :'end_time' => :'end_time',
        :'copy_video' => :'copy_video',
        :'copy_audio' => :'copy_audio',
        :'skip_video' => :'skip_video',
        :'skip_audio' => :'skip_audio',
        :'width' => :'width',
        :'height' => :'height',
        :'video_codec' => :'video_codec',
        :'h264_profile' => :'h264_profile',
        :'audio_codec' => :'audio_codec',
        :'notifications' => :'notifications',
        :'rendition_label' => :'rendition_label',
        :'type' => :'type',
        :'streams' => :'streams',
        :'url' => :'url',
        :'credentials' => :'credentials',
        :'videocloud' => :'videocloud'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'label' => :'String',
        :'live_stream' => :'BOOLEAN',
        :'keyframe_interval' => :'Integer',
        :'video_bitrate' => :'Integer',
        :'audio_bitrate' => :'Float',
        :'segment_seconds' => :'Float',
        :'duration' => :'Integer',
        :'ad_audio_loudness_level' => :'Float',
        :'stream_start_time' => :'Integer',
        :'stream_end_time' => :'Integer',
        :'start_time' => :'Integer',
        :'end_time' => :'Integer',
        :'copy_video' => :'BOOLEAN',
        :'copy_audio' => :'BOOLEAN',
        :'skip_video' => :'BOOLEAN',
        :'skip_audio' => :'BOOLEAN',
        :'width' => :'Integer',
        :'height' => :'Integer',
        :'video_codec' => :'String',
        :'h264_profile' => :'String',
        :'audio_codec' => :'String',
        :'notifications' => :'Array<Object>',
        :'rendition_label' => :'String',
        :'type' => :'String',
        :'streams' => :'Object',
        :'url' => :'String',
        :'credentials' => :'String',
        :'videocloud' => :'CreateVodClipbodyOutputsVideocloud'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'label')
        self.label = attributes[:'label']
      end

      if attributes.has_key?(:'live_stream')
        self.live_stream = attributes[:'live_stream']
      end

      if attributes.has_key?(:'keyframe_interval')
        self.keyframe_interval = attributes[:'keyframe_interval']
      end

      if attributes.has_key?(:'video_bitrate')
        self.video_bitrate = attributes[:'video_bitrate']
      end

      if attributes.has_key?(:'audio_bitrate')
        self.audio_bitrate = attributes[:'audio_bitrate']
      end

      if attributes.has_key?(:'segment_seconds')
        self.segment_seconds = attributes[:'segment_seconds']
      end

      if attributes.has_key?(:'duration')
        self.duration = attributes[:'duration']
      end

      if attributes.has_key?(:'ad_audio_loudness_level')
        self.ad_audio_loudness_level = attributes[:'ad_audio_loudness_level']
      end

      if attributes.has_key?(:'stream_start_time')
        self.stream_start_time = attributes[:'stream_start_time']
      end

      if attributes.has_key?(:'stream_end_time')
        self.stream_end_time = attributes[:'stream_end_time']
      end

      if attributes.has_key?(:'start_time')
        self.start_time = attributes[:'start_time']
      end

      if attributes.has_key?(:'end_time')
        self.end_time = attributes[:'end_time']
      end

      if attributes.has_key?(:'copy_video')
        self.copy_video = attributes[:'copy_video']
      end

      if attributes.has_key?(:'copy_audio')
        self.copy_audio = attributes[:'copy_audio']
      end

      if attributes.has_key?(:'skip_video')
        self.skip_video = attributes[:'skip_video']
      end

      if attributes.has_key?(:'skip_audio')
        self.skip_audio = attributes[:'skip_audio']
      end

      if attributes.has_key?(:'width')
        self.width = attributes[:'width']
      else
        self.width = 640
      end

      if attributes.has_key?(:'height')
        self.height = attributes[:'height']
      else
        self.height = 480
      end

      if attributes.has_key?(:'video_codec')
        self.video_codec = attributes[:'video_codec']
      end

      if attributes.has_key?(:'h264_profile')
        self.h264_profile = attributes[:'h264_profile']
      end

      if attributes.has_key?(:'audio_codec')
        self.audio_codec = attributes[:'audio_codec']
      end

      if attributes.has_key?(:'notifications')
        if (value = attributes[:'notifications']).is_a?(Array)
          self.notifications = value
        end
      end

      if attributes.has_key?(:'rendition_label')
        self.rendition_label = attributes[:'rendition_label']
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.has_key?(:'streams')
        self.streams = attributes[:'streams']
      end

      if attributes.has_key?(:'url')
        self.url = attributes[:'url']
      end

      if attributes.has_key?(:'credentials')
        self.credentials = attributes[:'credentials']
      end

      if attributes.has_key?(:'videocloud')
        self.videocloud = attributes[:'videocloud']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @label.nil?
        invalid_properties.push('invalid value for "label", label cannot be nil.')
      end

      if @live_stream.nil?
        invalid_properties.push('invalid value for "live_stream", live_stream cannot be nil.')
      end

      if @keyframe_interval.nil?
        invalid_properties.push('invalid value for "keyframe_interval", keyframe_interval cannot be nil.')
      end

      if @keyframe_interval > 6000
        invalid_properties.push('invalid value for "keyframe_interval", must be smaller than or equal to 6000.')
      end

      if @keyframe_interval < 1
        invalid_properties.push('invalid value for "keyframe_interval", must be greater than or equal to 1.')
      end

      if @video_bitrate.nil?
        invalid_properties.push('invalid value for "video_bitrate", video_bitrate cannot be nil.')
      end

      if @video_bitrate > 10000
        invalid_properties.push('invalid value for "video_bitrate", must be smaller than or equal to 10000.')
      end

      if @video_bitrate < 64
        invalid_properties.push('invalid value for "video_bitrate", must be greater than or equal to 64.')
      end

      if @audio_bitrate.nil?
        invalid_properties.push('invalid value for "audio_bitrate", audio_bitrate cannot be nil.')
      end

      if @audio_bitrate > 1024
        invalid_properties.push('invalid value for "audio_bitrate", must be smaller than or equal to 1024.')
      end

      if @audio_bitrate < 16
        invalid_properties.push('invalid value for "audio_bitrate", must be greater than or equal to 16.')
      end

      if @segment_seconds.nil?
        invalid_properties.push('invalid value for "segment_seconds", segment_seconds cannot be nil.')
      end

      if @segment_seconds > 20
        invalid_properties.push('invalid value for "segment_seconds", must be smaller than or equal to 20.')
      end

      if @segment_seconds < 2
        invalid_properties.push('invalid value for "segment_seconds", must be greater than or equal to 2.')
      end

      if !@duration.nil? && @duration > 172800
        invalid_properties.push('invalid value for "duration", must be smaller than or equal to 172800.')
      end

      if !@duration.nil? && @duration < 0
        invalid_properties.push('invalid value for "duration", must be greater than or equal to 0.')
      end

      if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level > 60
        invalid_properties.push('invalid value for "ad_audio_loudness_level", must be smaller than or equal to 60.')
      end

      if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level < -60
        invalid_properties.push('invalid value for "ad_audio_loudness_level", must be greater than or equal to -60.')
      end

      if !@stream_start_time.nil? && @stream_start_time > 2147483647
        invalid_properties.push('invalid value for "stream_start_time", must be smaller than or equal to 2147483647.')
      end

      if !@stream_start_time.nil? && @stream_start_time < 0
        invalid_properties.push('invalid value for "stream_start_time", must be greater than or equal to 0.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @label.nil?
      return false if @live_stream.nil?
      return false if @keyframe_interval.nil?
      return false if @keyframe_interval > 6000
      return false if @keyframe_interval < 1
      return false if @video_bitrate.nil?
      return false if @video_bitrate > 10000
      return false if @video_bitrate < 64
      return false if @audio_bitrate.nil?
      return false if @audio_bitrate > 1024
      return false if @audio_bitrate < 16
      return false if @segment_seconds.nil?
      return false if @segment_seconds > 20
      return false if @segment_seconds < 2
      return false if !@duration.nil? && @duration > 172800
      return false if !@duration.nil? && @duration < 0
      return false if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level > 60
      return false if !@ad_audio_loudness_level.nil? && @ad_audio_loudness_level < -60
      return false if !@stream_start_time.nil? && @stream_start_time > 2147483647
      return false if !@stream_start_time.nil? && @stream_start_time < 0
      video_codec_validator = EnumAttributeValidator.new('String', ['h264'])
      return false unless video_codec_validator.valid?(@video_codec)
      h264_profile_validator = EnumAttributeValidator.new('String', ['baseline', 'main', 'high'])
      return false unless h264_profile_validator.valid?(@h264_profile)
      audio_codec_validator = EnumAttributeValidator.new('String', ['aac'])
      return false unless audio_codec_validator.valid?(@audio_codec)
      type_validator = EnumAttributeValidator.new('String', ['playlist'])
      return false unless type_validator.valid?(@type)
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] keyframe_interval Value to be assigned
    def keyframe_interval=(keyframe_interval)
      if keyframe_interval.nil?
        fail ArgumentError, 'keyframe_interval cannot be nil'
      end

      if keyframe_interval > 6000
        fail ArgumentError, 'invalid value for "keyframe_interval", must be smaller than or equal to 6000.'
      end

      if keyframe_interval < 1
        fail ArgumentError, 'invalid value for "keyframe_interval", must be greater than or equal to 1.'
      end

      @keyframe_interval = keyframe_interval
    end

    # Custom attribute writer method with validation
    # @param [Object] video_bitrate Value to be assigned
    def video_bitrate=(video_bitrate)
      if video_bitrate.nil?
        fail ArgumentError, 'video_bitrate cannot be nil'
      end

      if video_bitrate > 10000
        fail ArgumentError, 'invalid value for "video_bitrate", must be smaller than or equal to 10000.'
      end

      if video_bitrate < 64
        fail ArgumentError, 'invalid value for "video_bitrate", must be greater than or equal to 64.'
      end

      @video_bitrate = video_bitrate
    end

    # Custom attribute writer method with validation
    # @param [Object] audio_bitrate Value to be assigned
    def audio_bitrate=(audio_bitrate)
      if audio_bitrate.nil?
        fail ArgumentError, 'audio_bitrate cannot be nil'
      end

      if audio_bitrate > 1024
        fail ArgumentError, 'invalid value for "audio_bitrate", must be smaller than or equal to 1024.'
      end

      if audio_bitrate < 16
        fail ArgumentError, 'invalid value for "audio_bitrate", must be greater than or equal to 16.'
      end

      @audio_bitrate = audio_bitrate
    end

    # Custom attribute writer method with validation
    # @param [Object] segment_seconds Value to be assigned
    def segment_seconds=(segment_seconds)
      if segment_seconds.nil?
        fail ArgumentError, 'segment_seconds cannot be nil'
      end

      if segment_seconds > 20
        fail ArgumentError, 'invalid value for "segment_seconds", must be smaller than or equal to 20.'
      end

      if segment_seconds < 2
        fail ArgumentError, 'invalid value for "segment_seconds", must be greater than or equal to 2.'
      end

      @segment_seconds = segment_seconds
    end

    # Custom attribute writer method with validation
    # @param [Object] duration Value to be assigned
    def duration=(duration)
      if !duration.nil? && duration > 172800
        fail ArgumentError, 'invalid value for "duration", must be smaller than or equal to 172800.'
      end

      if !duration.nil? && duration < 0
        fail ArgumentError, 'invalid value for "duration", must be greater than or equal to 0.'
      end

      @duration = duration
    end

    # Custom attribute writer method with validation
    # @param [Object] ad_audio_loudness_level Value to be assigned
    def ad_audio_loudness_level=(ad_audio_loudness_level)
      if !ad_audio_loudness_level.nil? && ad_audio_loudness_level > 60
        fail ArgumentError, 'invalid value for "ad_audio_loudness_level", must be smaller than or equal to 60.'
      end

      if !ad_audio_loudness_level.nil? && ad_audio_loudness_level < -60
        fail ArgumentError, 'invalid value for "ad_audio_loudness_level", must be greater than or equal to -60.'
      end

      @ad_audio_loudness_level = ad_audio_loudness_level
    end

    # Custom attribute writer method with validation
    # @param [Object] stream_start_time Value to be assigned
    def stream_start_time=(stream_start_time)
      if !stream_start_time.nil? && stream_start_time > 2147483647
        fail ArgumentError, 'invalid value for "stream_start_time", must be smaller than or equal to 2147483647.'
      end

      if !stream_start_time.nil? && stream_start_time < 0
        fail ArgumentError, 'invalid value for "stream_start_time", must be greater than or equal to 0.'
      end

      @stream_start_time = stream_start_time
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] video_codec Object to be assigned
    def video_codec=(video_codec)
      validator = EnumAttributeValidator.new('String', ['h264'])
      unless validator.valid?(video_codec)
        fail ArgumentError, 'invalid value for "video_codec", must be one of #{validator.allowable_values}.'
      end
      @video_codec = video_codec
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] h264_profile Object to be assigned
    def h264_profile=(h264_profile)
      validator = EnumAttributeValidator.new('String', ['baseline', 'main', 'high'])
      unless validator.valid?(h264_profile)
        fail ArgumentError, 'invalid value for "h264_profile", must be one of #{validator.allowable_values}.'
      end
      @h264_profile = h264_profile
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] audio_codec Object to be assigned
    def audio_codec=(audio_codec)
      validator = EnumAttributeValidator.new('String', ['aac'])
      unless validator.valid?(audio_codec)
        fail ArgumentError, 'invalid value for "audio_codec", must be one of #{validator.allowable_values}.'
      end
      @audio_codec = audio_codec
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] type Object to be assigned
    def type=(type)
      validator = EnumAttributeValidator.new('String', ['playlist'])
      unless validator.valid?(type)
        fail ArgumentError, 'invalid value for "type", must be one of #{validator.allowable_values}.'
      end
      @type = type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          label == o.label &&
          live_stream == o.live_stream &&
          keyframe_interval == o.keyframe_interval &&
          video_bitrate == o.video_bitrate &&
          audio_bitrate == o.audio_bitrate &&
          segment_seconds == o.segment_seconds &&
          duration == o.duration &&
          ad_audio_loudness_level == o.ad_audio_loudness_level &&
          stream_start_time == o.stream_start_time &&
          stream_end_time == o.stream_end_time &&
          start_time == o.start_time &&
          end_time == o.end_time &&
          copy_video == o.copy_video &&
          copy_audio == o.copy_audio &&
          skip_video == o.skip_video &&
          skip_audio == o.skip_audio &&
          width == o.width &&
          height == o.height &&
          video_codec == o.video_codec &&
          h264_profile == o.h264_profile &&
          audio_codec == o.audio_codec &&
          notifications == o.notifications &&
          rendition_label == o.rendition_label &&
          type == o.type &&
          streams == o.streams &&
          url == o.url &&
          credentials == o.credentials &&
          videocloud == o.videocloud
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [label, live_stream, keyframe_interval, video_bitrate, audio_bitrate, segment_seconds, duration, ad_audio_loudness_level, stream_start_time, stream_end_time, start_time, end_time, copy_video, copy_audio, skip_video, skip_audio, width, height, video_codec, h264_profile, audio_codec, notifications, rendition_label, type, streams, url, credentials, videocloud].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = BrightcoveLive.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
